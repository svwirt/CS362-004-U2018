Running Random Card Test for Village
Hand Test 0 passed: before-293 after-293
Deck Test 0 passed: before-277 after-276
Discard Test 0 passed: before-415 after-415
Actions Test 0 passed: before-1 after-3
Hand Test 1 passed: before-421 after-421
Deck Test 1 passed: before-492 after-491
Discard Test 1 passed: before-149 after-149
Actions Test 1 passed: before-1 after-3
Hand Test 2 passed: before-263 after-263
Deck Test 2 passed: before-190 after-189
Discard Test 2 passed: before-59 after-59
Actions Test 2 passed: before-1 after-3
Hand Test 3 passed: before-236 after-236
Deck Test 3 passed: before-426 after-425
Discard Test 3 passed: before-172 after-172
Actions Test 3 passed: before-1 after-3
Hand Test 4 passed: before-282 after-282
Deck Test 4 passed: before-67 after-66
Discard Test 4 passed: before-429 after-429
Actions Test 4 passed: before-1 after-3
Hand Test 5 passed: before-135 after-135
Deck Test 5 passed: before-123 after-122
Discard Test 5 passed: before-67 after-67
Actions Test 5 passed: before-1 after-3
Hand Test 6 passed: before-69 after-69
Deck Test 6 passed: before-22 after-21
Discard Test 6 passed: before-58 after-58
Actions Test 6 passed: before-3 after-5
Hand Test 7 passed: before-42 after-42
Deck Test 7 passed: before-456 after-455
Discard Test 7 passed: before-11 after-11
Actions Test 7 passed: before-1 after-3
Hand Test 8 passed: before-284 after-284
Deck Test 8 passed: before-421 after-420
Discard Test 8 passed: before-419 after-419
Actions Test 8 passed: before-3 after-5
Hand Test 9 passed: before-370 after-370
Deck Test 9 passed: before-324 after-323
Discard Test 9 passed: before-315 after-315
Actions Test 9 passed: before-5 after-7
Hand Test 10 passed: before-456 after-456
Deck Test 10 passed: before-91 after-90
Discard Test 10 passed: before-480 after-480
Actions Test 10 passed: before-7 after-9
Hand Test 11 passed: before-281 after-281
Deck Test 11 passed: before-170 after-169
Discard Test 11 passed: before-496 after-496
Actions Test 11 passed: before-9 after-11
Hand Test 12 passed: before-336 after-336
Deck Test 12 passed: before-84 after-83
Discard Test 12 passed: before-327 after-327
Actions Test 12 passed: before-11 after-13
Hand Test 13 passed: before-357 after-357
Deck Test 13 passed: before-229 after-228
Discard Test 13 passed: before-313 after-313
Actions Test 13 passed: before-13 after-15
Hand Test 14 passed: before-314 after-314
Deck Test 14 passed: before-82 after-81
Discard Test 14 passed: before-45 after-45
Actions Test 14 passed: before-15 after-17
Hand Test 15 passed: before-250 after-250
Deck Test 15 passed: before-364 after-363
Discard Test 15 passed: before-43 after-43
Actions Test 15 passed: before-1 after-3
Hand Test 16 passed: before-288 after-288
Deck Test 16 passed: before-276 after-275
Discard Test 16 passed: before-178 after-178
Actions Test 16 passed: before-1 after-3
Hand Test 17 passed: before-399 after-399
Deck Test 17 passed: before-151 after-150
Discard Test 17 passed: before-254 after-254
Actions Test 17 passed: before-3 after-5
Hand Test 18 passed: before-239 after-239
Deck Test 18 passed: before-176 after-175
Discard Test 18 passed: before-368 after-368
Actions Test 18 passed: before-5 after-7
Hand Test 19 passed: before-39 after-39
Deck Test 19 passed: before-86 after-85
Discard Test 19 passed: before-94 after-94
Actions Test 19 passed: before-7 after-9
Hand Test 20 passed: before-467 after-467
Deck Test 20 passed: before-434 after-433
Discard Test 20 passed: before-378 after-378
Actions Test 20 passed: before-1 after-3
Hand Test 21 passed: before-492 after-492
Deck Test 21 passed: before-402 after-401
Discard Test 21 passed: before-317 after-317
Actions Test 21 passed: before-3 after-5
Hand Test 22 passed: before-286 after-286
Deck Test 22 passed: before-301 after-300
Discard Test 22 passed: before-280 after-280
Actions Test 22 passed: before-5 after-7
Hand Test 23 passed: before-119 after-119
Deck Test 23 passed: before-189 after-188
Discard Test 23 passed: before-444 after-444
Actions Test 23 passed: before-7 after-9
Hand Test 24 passed: before-97 after-97
Deck Test 24 passed: before-31 after-30
Discard Test 24 passed: before-117 after-117
Actions Test 24 passed: before-9 after-11
Hand Test 25 passed: before-427 after-427
Deck Test 25 passed: before-175 after-174
Discard Test 25 passed: before-209 after-209
Actions Test 25 passed: before-1 after-3
Hand Test 26 passed: before-86 after-86
Deck Test 26 passed: before-497 after-496
Discard Test 26 passed: before-353 after-353
Actions Test 26 passed: before-1 after-3
Hand Test 27 passed: before-124 after-124
Deck Test 27 passed: before-183 after-182
Discard Test 27 passed: before-219 after-219
Actions Test 27 passed: before-3 after-5
Hand Test 28 passed: before-3 after-3
Deck Test 28 passed: before-232 after-231
Discard Test 28 passed: before-329 after-329
Actions Test 28 passed: before-5 after-7
Hand Test 29 passed: before-215 after-215
Deck Test 29 passed: before-368 after-367
Discard Test 29 passed: before-208 after-208
Actions Test 29 passed: before-1 after-3
Hand Test 30 passed: before-118 after-118
Deck Test 30 passed: before-296 after-295
Discard Test 30 passed: before-223 after-223
Actions Test 30 passed: before-3 after-5
Hand Test 31 passed: before-55 after-55
Deck Test 31 passed: before-451 after-450
Discard Test 31 passed: before-421 after-421
Actions Test 31 passed: before-5 after-7
Hand Test 32 passed: before-341 after-341
Deck Test 32 passed: before-264 after-263
Discard Test 32 passed: before-228 after-228
Actions Test 32 passed: before-1 after-3
Hand Test 33 passed: before-264 after-264
Deck Test 33 Test 0 failed: before-33 after--1548047992

Discard Test 33 failed: before-34 after-0
Actions Test 33 passed: before-1 after-3
Hand Test 34 passed: before-243 after-243
Deck Test 34 passed: before-487 after-486
Discard Test 34 passed: before-356 after-356
Actions Test 34 passed: before-3 after-5
Hand Test 35 passed: before-436 after-436
Deck Test 35 passed: before-365 after-364
Discard Test 35 passed: before-359 after-359
Actions Test 35 passed: before-1 after-3
Hand Test 36 passed: before-275 after-275
Deck Test 36 passed: before-437 after-436
Discard Test 36 passed: before-228 after-228
Actions Test 36 passed: before-3 after-5
Hand Test 37 passed: before-395 after-395
Deck Test 37 passed: before-121 after-120
Discard Test 37 passed: before-358 after-358
Actions Test 37 passed: before-1 after-3
Hand Test 38 passed: before-318 after-318
Deck Test 38 passed: before-235 after-234
Discard Test 38 passed: before-293 after-293
Actions Test 38 passed: before-3 after-5
Hand Test 39 passed: before-29 after-29
Deck Test 39 passed: before-11 after-10
Discard Test 39 passed: before-428 after-428
Actions Test 39 passed: before-5 after-7
Hand Test 40 passed: before-113 after-113
Deck Test 40 passed: before-443 after-442
Discard Test 40 passed: before-263 after-263
Actions Test 40 passed: before-7 after-9
Hand Test 41 passed: before-318 after-318
Deck Test 41 passed: before-340 after-339
Discard Test 41 passed: before-404 after-404
Actions Test 41 passed: before-1 after-3
Hand Test 42 passed: before-417 after-417
Deck Test 42 passed: before-369 after-368
Discard Test 42 passed: before-417 after-417
Actions Test 42 passed: before-3 after-5
Hand Test 43 passed: before-183 after-183
Deck Test 43 passed: before-243 after-242
Discard Test 43 passed: before-470 after-470
Actions Test 43 passed: before-5 after-7
Hand Test 44 passed: before-144 after-144
Deck Test 44 passed: before-272 after-271
Discard Test 44 passed: before-225 after-225
Actions Test 44 passed: before-1 after-3
Hand Test 45 passed: before-286 after-286
Deck Test 45 passed: before-139 after-138
Discard Test 45 passed: before-454 after-454
Actions Test 45 passed: before-1 after-3
Hand Test 46 passed: before-197 after-197
Deck Test 46 passed: before-42 after-41
Discard Test 46 passed: before-464 after-464
Actions Test 46 passed: before-3 after-5
Hand Test 47 passed: before-111 after-111
Deck Test 47 passed: before-304 after-303
Discard Test 47 passed: before-348 after-348
Actions Test 47 passed: before-1 after-3
Hand Test 48 passed: before-246 after-246
Deck Test 48 passed: before-299 after-298
Discard Test 48 passed: before-343 after-343
Actions Test 48 passed: before-1 after-3
Hand Test 49 passed: before-310 after-310
Deck Test 49 passed: before-422 after-421
Discard Test 49 passed: before-311 after-311
Actions Test 49 passed: before-3 after-5
Hand Test 50 passed: before-378 after-378
Deck Test 50 passed: before-161 after-160
Discard Test 50 passed: before-230 after-230
Actions Test 50 passed: before-5 after-7
Hand Test 51 passed: before-126 after-126
Deck Test 51 passed: before-236 after-235
Discard Test 51 passed: before-444 after-444
Actions Test 51 passed: before-7 after-9
Hand Test 52 passed: before-282 after-282
Deck Test 52 passed: before-208 after-207
Discard Test 52 passed: before-416 after-416
Actions Test 52 passed: before-1 after-3
Hand Test 53 passed: before-124 after-124
Deck Test 53 passed: before-137 after-136
Discard Test 53 passed: before-62 after-62
Actions Test 53 passed: before-1 after-3
Hand Test 54 passed: before-379 after-379
Deck Test 54 passed: before-452 after-451
Discard Test 54 passed: before-399 after-399
Actions Test 54 passed: before-3 after-5
Hand Test 55 passed: before-131 after-131
Deck Test 55 passed: before-71 after-70
Discard Test 55 passed: before-473 after-473
Actions Test 55 passed: before-1 after-3
Hand Test 56 passed: before-160 after-160
Deck Test 56 passed: before-433 after-432
Discard Test 56 passed: before-394 after-394
Actions Test 56 passed: before-3 after-5
Hand Test 57 passed: before-496 after-496
Deck Test 57 passed: before-481 after-480
Discard Test 57 passed: before-399 after-399
Actions Test 57 passed: before-1 after-3
Hand Test 58 passed: before-190 after-190
Deck Test 58 passed: before-313 after-312
Discard Test 58 passed: before-168 after-168
Actions Test 58 passed: before-1 after-3
Hand Test 59 passed: before-340 after-340
Deck Test 59 passed: before-466 after-465
Discard Test 59 passed: before-84 after-84
Actions Test 59 passed: before-1 after-3
Hand Test 60 passed: before-436 after-436
Deck Test 60 passed: before-376 after-375
Discard Test 60 passed: before-42 after-42
Actions Test 60 passed: before-1 after-3
Hand Test 61 passed: before-418 after-418
Deck Test 61 passed: before-256 after-255
Discard Test 61 passed: before-179 after-179
Actions Test 61 passed: before-1 after-3
Hand Test 62 passed: before-159 after-159
Deck Test 62 passed: before-348 after-347
Discard Test 62 passed: before-172 after-172
Actions Test 62 passed: before-1 after-3
Hand Test 63 passed: before-87 after-87
Deck Test 63 passed: before-210 after-209
Discard Test 63 passed: before-342 after-342
Actions Test 63 passed: before-3 after-5
Hand Test 64 passed: before-321 after-321
Deck Test 64 passed: before-213 after-212
Discard Test 64 passed: before-372 after-372
Actions Test 64 passed: before-1 after-3
Hand Test 65 passed: before-404 after-404
Deck Test 65 passed: before-99 after-98
Discard Test 65 passed: before-221 after-221
Actions Test 65 passed: before-1 after-3
Hand Test 66 passed: before-205 after-205
Deck Test 66 passed: before-440 after-439
Discard Test 66 passed: before-167 after-167
Actions Test 66 passed: before-1 after-3
Hand Test 67 passed: before-158 after-158
Deck Test 67 passed: before-150 after-149
Discard Test 67 passed: before-484 after-484
Actions Test 67 passed: before-3 after-5
Hand Test 68 passed: before-396 after-396
Deck Test 68 passed: before-422 after-421
Discard Test 68 passed: before-269 after-269
Actions Test 68 passed: before-5 after-7
Hand Test 69 passed: before-472 after-472
Deck Test 69 passed: before-84 after-83
Discard Test 69 passed: before-292 after-292
Actions Test 69 passed: before-7 after-9
Hand Test 70 passed: before-222 after-222
Deck Test 70 passed: before-125 after-124
Discard Test 70 passed: before-385 after-385
Actions Test 70 passed: before-9 after-11
Hand Test 71 passed: before-213 after-213
Deck Test 71 passed: before-42 after-41
Discard Test 71 passed: before-398 after-398
Actions Test 71 passed: before-1 after-3
Hand Test 72 passed: before-209 after-209
Deck Test 72 passed: before-24 after-23
Discard Test 72 passed: before-90 after-90
Actions Test 72 passed: before-1 after-3
Hand Test 73 passed: before-155 after-155
Deck Test 73 passed: before-336 after-335
Discard Test 73 passed: before-232 after-232
Actions Test 73 passed: before-3 after-5
Hand Test 74 passed: before-273 after-273
Deck Test 74 passed: before-379 after-378
Discard Test 74 passed: before-269 after-269
Actions Test 74 passed: before-1 after-3
Hand Test 75 passed: before-142 after-142
Deck Test 75 passed: before-255 after-254
Discard Test 75 passed: before-360 after-360
Actions Test 75 passed: before-3 after-5
Hand Test 76 passed: before-121 after-121
Deck Test 76 passed: before-493 after-492
Discard Test 76 passed: before-205 after-205
Actions Test 76 passed: before-1 after-3
Hand Test 77 passed: before-254 after-254
Deck Test 77 passed: before-113 after-112
Discard Test 77 passed: before-461 after-461
Actions Test 77 passed: before-1 after-3
Hand Test 78 passed: before-202 after-202
Deck Test 78 passed: before-444 after-443
Discard Test 78 passed: before-202 after-202
Actions Test 78 passed: before-1 after-3
Hand Test 79 passed: before-368 after-368
Deck Test 79 passed: before-21 after-20
Discard Test 79 passed: before-342 after-342
Actions Test 79 passed: before-1 after-3
Hand Test 80 passed: before-458 after-458
Deck Test 80 passed: before-372 after-371
Discard Test 80 passed: before-408 after-408
Actions Test 80 passed: before-3 after-5
Hand Test 81 passed: before-248 after-248
Deck Test 81 passed: before-308 after-307
Discard Test 81 passed: before-253 after-253
Actions Test 81 passed: before-1 after-3
Hand Test 82 passed: before-390 after-390
Deck Test 82 passed: before-133 after-132
Discard Test 82 passed: before-148 after-148
Actions Test 82 passed: before-1 after-3
Hand Test 83 passed: before-29 after-29
Deck Test 83 passed: before-246 after-245
Discard Test 83 passed: before-368 after-368
Actions Test 83 passed: before-1 after-3
Hand Test 84 passed: before-249 after-249
Deck Test 84 passed: before-288 after-287
Discard Test 84 passed: before-297 after-297
Actions Test 84 passed: before-3 after-5
Hand Test 85 passed: before-497 after-497
Deck Test 85 passed: before-33 after-32
Discard Test 85 passed: before-363 after-363
Actions Test 85 passed: before-1 after-3
Hand Test 86 passed: before-152 after-152
Deck Test 86 passed: before-186 after-185
Discard Test 86 passed: before-125 after-125
Actions Test 86 passed: before-3 after-5
Hand Test 87 passed: before-229 after-229
Deck Test 87 passed: before-188 after-187
Discard Test 87 passed: before-157 after-157
Actions Test 87 passed: before-5 after-7
Hand Test 88 passed: before-460 after-460
Deck Test 88 passed: before-414 after-413
Discard Test 88 passed: before-421 after-421
Actions Test 88 passed: before-7 after-9
Hand Test 89 passed: before-248 after-248
Deck Test 89 passed: before-27 after-26
Discard Test 89 passed: before-50 after-50
Actions Test 89 passed: before-9 after-11
Hand Test 90 passed: before-199 after-199
Deck Test 90 passed: before-294 after-293
Discard Test 90 passed: before-197 after-197
Actions Test 90 passed: before-11 after-13
Hand Test 91 passed: before-403 after-403
Deck Test 91 passed: before-2 after-1
Discard Test 91 passed: before-428 after-428
Actions Test 91 passed: before-1 after-3
Hand Test 92 passed: before-159 after-159
Deck Test 92 passed: before-147 after-146
Discard Test 92 passed: before-38 after-38
Actions Test 92 passed: before-3 after-5
Hand Test 93 passed: before-192 after-192
Deck Test 93 passed: before-134 after-133
Discard Test 93 passed: before-339 after-339
Actions Test 93 passed: before-1 after-3
Hand Test 94 passed: before-49 after-49
Deck Test 94 passed: before-4 after-3
Discard Test 94 passed: before-129 after-129
Actions Test 94 passed: before-1 after-3
Hand Test 95 passed: before-335 after-335
Deck Test 95 passed: before-429 after-428
Discard Test 95 passed: before-343 after-343
Actions Test 95 passed: before-3 after-5
Hand Test 96 passed: before-449 after-449
Deck Test 96 passed: before-238 after-237
Discard Test 96 passed: before-471 after-471
Actions Test 96 passed: before-5 after-7
Hand Test 97 passed: before-295 after-295
Deck Test 97 passed: before-488 after-487
Discard Test 97 passed: before-292 after-292
Actions Test 97 passed: before-7 after-9
Hand Test 98 passed: before-182 after-182
Deck Test 98 passed: before-329 after-328
Discard Test 98 passed: before-390 after-390
Actions Test 98 passed: before-1 after-3
Hand Test 99 passed: before-232 after-232
Deck Test 99 passed: before-69 after-68
Discard Test 99 passed: before-326 after-326
Actions Test 99 passed: before-3 after-5


Status: 2 failured and 398 passed tests
100 games run
File 'dominion.c'
Lines executed:23.93% of 560
Branches executed:24.22% of 417
Taken at least once:16.07% of 417
Calls executed:12.63% of 95
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:
        -:    2:#include "dominion.h"
        -:    3:#include "dominion_helpers.h"
        -:    4:#include "rngs.h"
        -:    5:#include <stdio.h>
        -:    6:#include <math.h>
        -:    7:#include <stdlib.h>
        -:    8:
function compare called 1988 returned 100% blocks executed 83%
     1988:    9:int compare(const void* a, const void* b) {
     1988:   10:  if (*(int*)a > *(int*)b)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   11:    return 1;
     1988:   12:  if (*(int*)a < *(int*)b)
branch  0 taken 26% (fallthrough)
branch  1 taken 74%
      508:   13:    return -1;
     1480:   14:  return 0;
        -:   15:}
        -:   16:
function newGame called 0 returned 0% blocks executed 0%
    #####:   17:struct gameState* newGame() {
    #####:   18:  struct gameState* g = malloc(sizeof(struct gameState));
    #####:   19:  return g;
        -:   20:}
        -:   21:
function kingdomCards called 0 returned 0% blocks executed 0%
    #####:   22:int* kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7,
        -:   23:		  int k8, int k9, int k10) {
    #####:   24:  int* k = malloc(10 * sizeof(int));
    #####:   25:  k[0] = k1;
    #####:   26:  k[1] = k2;
    #####:   27:  k[2] = k3;
    #####:   28:  k[3] = k4;
    #####:   29:  k[4] = k5;
    #####:   30:  k[5] = k6;
    #####:   31:  k[6] = k7;
    #####:   32:  k[7] = k8;
    #####:   33:  k[8] = k9;
    #####:   34:  k[9] = k10;
    #####:   35:  return k;
        -:   36:}
        -:   37:
function initializeGame called 100 returned 100% blocks executed 95%
      100:   38:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed,
        -:   39:		   struct gameState *state) {
        -:   40:
        -:   41:  int i;
        -:   42:  int j;
        -:   43:  int it;			
        -:   44:  //set up random number generator
      100:   45:  SelectStream(1);
call    0 returned 100%
      100:   46:  PutSeed((long)randomSeed);
call    0 returned 100%
        -:   47:  
        -:   48:  //check number of players
      100:   49:  if (numPlayers > MAX_PLAYERS || numPlayers < 2)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 51% (fallthrough)
branch  3 taken 49%
        -:   50:    {
       51:   51:      return -1;
        -:   52:    }
        -:   53:
        -:   54:  //set number of players
       49:   55:  state->numPlayers = numPlayers;
        -:   56:
        -:   57:  //check selected kingdom cards are different
      539:   58:  for (i = 0; i < 10; i++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   59:    {
     5390:   60:      for (j = 0; j < 10; j++)
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -:   61:        {
     4900:   62:	  if (j != i && kingdomCards[j] == kingdomCards[i])
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -:   63:	    {
    #####:   64:	      return -1;
        -:   65:	    }
        -:   66:        }
        -:   67:    }
        -:   68:
        -:   69:
        -:   70:  //initialize supply
        -:   71:  ///////////////////////////////
        -:   72:
        -:   73:  //set number of Curse cards
       49:   74:  if (numPlayers == 2)
branch  0 taken 41% (fallthrough)
branch  1 taken 59%
        -:   75:    {
       20:   76:      state->supplyCount[curse] = 10;
        -:   77:    }
       29:   78:  else if (numPlayers == 3)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:   79:    {
       29:   80:      state->supplyCount[curse] = 20;
        -:   81:    }
        -:   82:  else
        -:   83:    {
    #####:   84:      state->supplyCount[curse] = 30;
        -:   85:    }
        -:   86:
        -:   87:  //set number of Victory cards
       49:   88:  if (numPlayers == 2)
branch  0 taken 41% (fallthrough)
branch  1 taken 59%
        -:   89:    {
       20:   90:      state->supplyCount[estate] = 8;
       20:   91:      state->supplyCount[duchy] = 8;
       20:   92:      state->supplyCount[province] = 8;
        -:   93:    }
        -:   94:  else
        -:   95:    {
       29:   96:      state->supplyCount[estate] = 12;
       29:   97:      state->supplyCount[duchy] = 12;
       29:   98:      state->supplyCount[province] = 12;
        -:   99:    }
        -:  100:
        -:  101:  //set number of Treasure cards
       49:  102:  state->supplyCount[copper] = 60 - (7 * numPlayers);
       49:  103:  state->supplyCount[silver] = 40;
       49:  104:  state->supplyCount[gold] = 30;
        -:  105:
        -:  106:  //set number of Kingdom cards
     1029:  107:  for (i = adventurer; i <= treasure_map; i++)       	//loop all cards
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -:  108:    {
     8085:  109:      for (j = 0; j < 10; j++)           		//loop chosen cards
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -:  110:	{
     7595:  111:	  if (kingdomCards[j] == i)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -:  112:	    {
        -:  113:	      //check if card is a 'Victory' Kingdom card
      490:  114:	      if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 10% (fallthrough)
branch  3 taken 90%
        -:  115:		{
       98:  116:		  if (numPlayers == 2){ 
branch  0 taken 41% (fallthrough)
branch  1 taken 59%
       20:  117:		    state->supplyCount[i] = 8; 
        -:  118:		  }
       29:  119:		  else{ state->supplyCount[i] = 12; }
        -:  120:		}
        -:  121:	      else
        -:  122:		{
      441:  123:		  state->supplyCount[i] = 10;
        -:  124:		}
      490:  125:	      break;
        -:  126:	    }
        -:  127:	  else    //card is not in the set choosen for the game
        -:  128:	    {
     7105:  129:	      state->supplyCount[i] = -1;
        -:  130:	    }
        -:  131:	}
        -:  132:
        -:  133:    }
        -:  134:
        -:  135:  ////////////////////////
        -:  136:  //supply intilization complete
        -:  137:
        -:  138:  //set player decks
      176:  139:  for (i = 0; i < numPlayers; i++)
branch  0 taken 72%
branch  1 taken 28% (fallthrough)
        -:  140:    {
      127:  141:      state->deckCount[i] = 0;
      508:  142:      for (j = 0; j < 3; j++)
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
        -:  143:	{
      381:  144:	  state->deck[i][j] = estate;
      381:  145:	  state->deckCount[i]++;
        -:  146:	}
     1016:  147:      for (j = 3; j < 10; j++)
branch  0 taken 88%
branch  1 taken 13% (fallthrough)
        -:  148:	{
      889:  149:	  state->deck[i][j] = copper;
      889:  150:	  state->deckCount[i]++;		
        -:  151:	}
        -:  152:    }
        -:  153:
        -:  154:  //shuffle player decks
      176:  155:  for (i = 0; i < numPlayers; i++)
branch  0 taken 72%
branch  1 taken 28% (fallthrough)
        -:  156:    {
      127:  157:      if ( shuffle(i, state) < 0 )
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
        -:  158:	{
    #####:  159:	  return -1;
        -:  160:	}
        -:  161:    }
        -:  162:
        -:  163:  //draw player hands
      176:  164:  for (i = 0; i < numPlayers; i++)
branch  0 taken 72%
branch  1 taken 28% (fallthrough)
        -:  165:    {  
        -:  166:      //initialize hand size to zero
      127:  167:      state->handCount[i] = 0;
      127:  168:      state->discardCount[i] = 0;
        -:  169:      //draw 5 cards
        -:  170:      // for (j = 0; j < 5; j++)
        -:  171:      //	{
        -:  172:      //	  drawCard(i, state);
        -:  173:      //	}
        -:  174:    }
        -:  175:  
        -:  176:  //set embargo tokens to 0 for all supply piles
     1372:  177:  for (i = 0; i <= treasure_map; i++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -:  178:    {
     1323:  179:      state->embargoTokens[i] = 0;
        -:  180:    }
        -:  181:
        -:  182:  //initialize first player's turn
       49:  183:  state->outpostPlayed = 0;
       49:  184:  state->phase = 0;
       49:  185:  state->numActions = 1;
       49:  186:  state->numBuys = 1;
       49:  187:  state->playedCardCount = 0;
       49:  188:  state->whoseTurn = 0;
       49:  189:  state->handCount[state->whoseTurn] = 0;
        -:  190:  //int it; move to top
        -:  191:
        -:  192:  //Moved draw cards to here, only drawing at the start of a turn
      294:  193:  for (it = 0; it < 5; it++){
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
      245:  194:    drawCard(state->whoseTurn, state);
call    0 returned 100%
        -:  195:  }
        -:  196:
       49:  197:  updateCoins(state->whoseTurn, state, 0);
call    0 returned 100%
        -:  198:
       49:  199:  return 0;
        -:  200:}
        -:  201:
function shuffle called 128 returned 100% blocks executed 94%
      128:  202:int shuffle(int player, struct gameState *state) {
        -:  203: 
        -:  204:
        -:  205:  int newDeck[MAX_DECK];
      128:  206:  int newDeckPos = 0;
        -:  207:  int card;
        -:  208:  int i;
        -:  209:
      128:  210:  if (state->deckCount[player] < 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  211:    return -1;
      128:  212:  qsort ((void*)(state->deck[player]), state->deckCount[player], sizeof(int), compare); 
call    0 returned 100%
        -:  213:  /* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  214:
     1560:  215:  while (state->deckCount[player] > 0) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     1304:  216:    card = floor(Random() * state->deckCount[player]);
call    0 returned 100%
     1304:  217:    newDeck[newDeckPos] = state->deck[player][card];
     1304:  218:    newDeckPos++;
     4513:  219:    for (i = card; i < state->deckCount[player]-1; i++) {
branch  0 taken 71%
branch  1 taken 29% (fallthrough)
     3209:  220:      state->deck[player][i] = state->deck[player][i+1];
        -:  221:    }
     1304:  222:    state->deckCount[player]--;
        -:  223:  }
     1432:  224:  for (i = 0; i < newDeckPos; i++) {
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
     1304:  225:    state->deck[player][i] = newDeck[i];
     1304:  226:    state->deckCount[player]++;
        -:  227:  }
        -:  228:
      128:  229:  return 0;
        -:  230:}
        -:  231:
function playCard called 0 returned 0% blocks executed 0%
    #####:  232:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state) 
        -:  233:{	
        -:  234:  int card;
    #####:  235:  int coin_bonus = 0; 		//tracks coins gain from actions
        -:  236:
        -:  237:  //check if it is the right phase
    #####:  238:  if (state->phase != 0)
branch  0 never executed
branch  1 never executed
        -:  239:    {
    #####:  240:      return -1;
        -:  241:    }
        -:  242:	
        -:  243:  //check if player has enough actions
    #####:  244:  if ( state->numActions < 1 )
branch  0 never executed
branch  1 never executed
        -:  245:    {
    #####:  246:      return -1;
        -:  247:    }
        -:  248:	
        -:  249:  //get card played
    #####:  250:  card = handCard(handPos, state);
call    0 never executed
        -:  251:	
        -:  252:  //check if selected card is an action
    #####:  253:  if ( card < adventurer || card > treasure_map )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  254:    {
    #####:  255:      return -1;
        -:  256:    }
        -:  257:	
        -:  258:  //play card
    #####:  259:  if ( cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  260:    {
    #####:  261:      return -1;
        -:  262:    }
        -:  263:	
        -:  264:  //reduce number of actions
    #####:  265:  state->numActions--;
        -:  266:
        -:  267:  //update coins (Treasure cards may be added with card draws)
    #####:  268:  updateCoins(state->whoseTurn, state, coin_bonus);
call    0 never executed
        -:  269:	
    #####:  270:  return 0;
        -:  271:}
        -:  272:
function buyCard called 0 returned 0% blocks executed 0%
    #####:  273:int buyCard(int supplyPos, struct gameState *state) {
        -:  274:  int who;
        -:  275:  if (DEBUG){
        -:  276:    printf("Entering buyCard...\n");
        -:  277:  }
        -:  278:
        -:  279:  // I don't know what to do about the phase thing.
        -:  280:
    #####:  281:  who = state->whoseTurn;
        -:  282:
    #####:  283:  if (state->numBuys < 1){
branch  0 never executed
branch  1 never executed
        -:  284:    if (DEBUG)
        -:  285:      printf("You do not have any buys left\n");
    #####:  286:    return -1;
    #####:  287:  } else if (supplyCount(supplyPos, state) <1){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  288:    if (DEBUG)
        -:  289:      printf("There are not any of that type of card left\n");
    #####:  290:    return -1;
    #####:  291:  } else if (state->coins < getCost(supplyPos)){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  292:    if (DEBUG) 
        -:  293:      printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  294:    return -1;
        -:  295:  } else {
    #####:  296:    state->phase=1;
        -:  297:    //state->supplyCount[supplyPos]--;
    #####:  298:    gainCard(supplyPos, state, 0, who); //card goes in discard, this might be wrong.. (2 means goes into hand, 0 goes into discard)
call    0 never executed
        -:  299:  
    #####:  300:    state->coins = (state->coins) - (getCost(supplyPos));
call    0 never executed
    #####:  301:    state->numBuys--;
        -:  302:    if (DEBUG)
        -:  303:      printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n", supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  304:  }
        -:  305:
        -:  306:  //state->discard[who][state->discardCount[who]] = supplyPos;
        -:  307:  //state->discardCount[who]++;
        -:  308:    
    #####:  309:  return 0;
        -:  310:}
        -:  311:
function numHandCards called 0 returned 0% blocks executed 0%
    #####:  312:int numHandCards(struct gameState *state) {
    #####:  313:  return state->handCount[ whoseTurn(state) ];
call    0 never executed
        -:  314:}
        -:  315:
function handCard called 0 returned 0% blocks executed 0%
    #####:  316:int handCard(int handPos, struct gameState *state) {
    #####:  317:  int currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  318:  return state->hand[currentPlayer][handPos];
        -:  319:}
        -:  320:
function supplyCount called 0 returned 0% blocks executed 0%
    #####:  321:int supplyCount(int card, struct gameState *state) {
    #####:  322:  return state->supplyCount[card];
        -:  323:}
        -:  324:
function fullDeckCount called 0 returned 0% blocks executed 0%
    #####:  325:int fullDeckCount(int player, int card, struct gameState *state) {
        -:  326:  int i;
    #####:  327:  int count = 0;
        -:  328:
    #####:  329:  for (i = 0; i < state->deckCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  330:    {
    #####:  331:      if (state->deck[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  332:    }
        -:  333:
    #####:  334:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  335:    {
    #####:  336:      if (state->hand[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  337:    }
        -:  338:
    #####:  339:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  340:    {
    #####:  341:      if (state->discard[player][i] == card) count++;
branch  0 never executed
branch  1 never executed
        -:  342:    }
        -:  343:
    #####:  344:  return count;
        -:  345:}
        -:  346:
function whoseTurn called 100 returned 100% blocks executed 100%
      100:  347:int whoseTurn(struct gameState *state) {
      100:  348:  return state->whoseTurn;
        -:  349:}
        -:  350:
function endTurn called 0 returned 0% blocks executed 0%
    #####:  351:int endTurn(struct gameState *state) {
        -:  352:  int k;
        -:  353:  int i;
    #####:  354:  int currentPlayer = whoseTurn(state);
call    0 never executed
        -:  355:  
        -:  356:  //Discard hand
    #####:  357:  for (i = 0; i < state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  358:    state->discard[currentPlayer][state->discardCount[currentPlayer]++] = state->hand[currentPlayer][i];//Discard
    #####:  359:    state->hand[currentPlayer][i] = -1;//Set card to -1
        -:  360:  }
    #####:  361:  state->handCount[currentPlayer] = 0;//Reset hand count
        -:  362:    
        -:  363:  //Code for determining the player
    #####:  364:  if (currentPlayer < (state->numPlayers - 1)){ 
branch  0 never executed
branch  1 never executed
    #####:  365:    state->whoseTurn = currentPlayer + 1;//Still safe to increment
        -:  366:  }
        -:  367:  else{
    #####:  368:    state->whoseTurn = 0;//Max player has been reached, loop back around to player 1
        -:  369:  }
        -:  370:
    #####:  371:  state->outpostPlayed = 0;
    #####:  372:  state->phase = 0;
    #####:  373:  state->numActions = 1;
    #####:  374:  state->coins = 0;
    #####:  375:  state->numBuys = 1;
    #####:  376:  state->playedCardCount = 0;
    #####:  377:  state->handCount[state->whoseTurn] = 0;
        -:  378:
        -:  379:  //int k; move to top
        -:  380:  //Next player draws hand
    #####:  381:  for (k = 0; k < 5; k++){
branch  0 never executed
branch  1 never executed
    #####:  382:    drawCard(state->whoseTurn, state);//Draw a card
call    0 never executed
        -:  383:  }
        -:  384:
        -:  385:  //Update money
    #####:  386:  updateCoins(state->whoseTurn, state , 0);
call    0 never executed
        -:  387:
    #####:  388:  return 0;
        -:  389:}
        -:  390:
function isGameOver called 0 returned 0% blocks executed 0%
    #####:  391:int isGameOver(struct gameState *state) {
        -:  392:  int i;
        -:  393:  int j;
        -:  394:	
        -:  395:  //if stack of Province cards is empty, the game ends
    #####:  396:  if (state->supplyCount[province] == 0)
branch  0 never executed
branch  1 never executed
        -:  397:    {
    #####:  398:      return 1;
        -:  399:    }
        -:  400:
        -:  401:  //if three supply pile are at 0, the game ends
    #####:  402:  j = 0;
    #####:  403:  for (i = 0; i < 25; i++)
branch  0 never executed
branch  1 never executed
        -:  404:    {
    #####:  405:      if (state->supplyCount[i] == 0)
branch  0 never executed
branch  1 never executed
        -:  406:	{
    #####:  407:	  j++;
        -:  408:	}
        -:  409:    }
    #####:  410:  if ( j >= 3)
branch  0 never executed
branch  1 never executed
        -:  411:    {
    #####:  412:      return 1;
        -:  413:    }
        -:  414:
    #####:  415:  return 0;
        -:  416:}
        -:  417:
function scoreFor called 0 returned 0% blocks executed 0%
    #####:  418:int scoreFor (int player, struct gameState *state) {
        -:  419:
        -:  420:  int i;
    #####:  421:  int score = 0;
        -:  422:  //score from hand
    #####:  423:  for (i = 0; i < state->handCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  424:    {
    #####:  425:      if (state->hand[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  426:      if (state->hand[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  427:      if (state->hand[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  428:      if (state->hand[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  429:      if (state->hand[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  430:      if (state->hand[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  431:    }
        -:  432:
        -:  433:  //score from discard
    #####:  434:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  435:    {
    #####:  436:      if (state->discard[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  437:      if (state->discard[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  438:      if (state->discard[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  439:      if (state->discard[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  440:      if (state->discard[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  441:      if (state->discard[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  442:    }
        -:  443:
        -:  444:  //score from deck
    #####:  445:  for (i = 0; i < state->discardCount[player]; i++)
branch  0 never executed
branch  1 never executed
        -:  446:    {
    #####:  447:      if (state->deck[player][i] == curse) { score = score - 1; };
branch  0 never executed
branch  1 never executed
    #####:  448:      if (state->deck[player][i] == estate) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  449:      if (state->deck[player][i] == duchy) { score = score + 3; };
branch  0 never executed
branch  1 never executed
    #####:  450:      if (state->deck[player][i] == province) { score = score + 6; };
branch  0 never executed
branch  1 never executed
    #####:  451:      if (state->deck[player][i] == great_hall) { score = score + 1; };
branch  0 never executed
branch  1 never executed
    #####:  452:      if (state->deck[player][i] == gardens) { score = score + ( fullDeckCount(player, 0, state) / 10 ); };
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  453:    }
        -:  454:
    #####:  455:  return score;
        -:  456:}
        -:  457:
function getWinners called 0 returned 0% blocks executed 0%
    #####:  458:int getWinners(int players[MAX_PLAYERS], struct gameState *state) {
        -:  459:  int i;	
        -:  460:  int j;
        -:  461:  int highScore;
        -:  462:  int currentPlayer;
        -:  463:
        -:  464:  //get score for each player
    #####:  465:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  466:    {
        -:  467:      //set unused player scores to -9999
    #####:  468:      if (i >= state->numPlayers)
branch  0 never executed
branch  1 never executed
        -:  469:	{
    #####:  470:	  players[i] = -9999;
        -:  471:	}
        -:  472:      else
        -:  473:	{
    #####:  474:	  players[i] = scoreFor (i, state);
call    0 never executed
        -:  475:	}
        -:  476:    }
        -:  477:
        -:  478:  //find highest score
    #####:  479:  j = 0;
    #####:  480:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  481:    {
    #####:  482:      if (players[i] > players[j])
branch  0 never executed
branch  1 never executed
        -:  483:	{
    #####:  484:	  j = i;
        -:  485:	}
        -:  486:    }
    #####:  487:  highScore = players[j];
        -:  488:
        -:  489:  //add 1 to players who had less turns
    #####:  490:  currentPlayer = whoseTurn(state);
call    0 never executed
    #####:  491:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  492:    {
    #####:  493:      if ( players[i] == highScore && i > currentPlayer )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  494:	{
    #####:  495:	  players[i]++;
        -:  496:	}
        -:  497:    }
        -:  498:
        -:  499:  //find new highest score
    #####:  500:  j = 0;
    #####:  501:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  502:    {
    #####:  503:      if ( players[i] > players[j] )
branch  0 never executed
branch  1 never executed
        -:  504:	{
    #####:  505:	  j = i;
        -:  506:	}
        -:  507:    }
    #####:  508:  highScore = players[j];
        -:  509:
        -:  510:  //set winners in array to 1 and rest to 0
    #####:  511:  for (i = 0; i < MAX_PLAYERS; i++)
branch  0 never executed
branch  1 never executed
        -:  512:    {
    #####:  513:      if ( players[i] == highScore )
branch  0 never executed
branch  1 never executed
        -:  514:	{
    #####:  515:	  players[i] = 1;
        -:  516:	}
        -:  517:      else
        -:  518:	{
    #####:  519:	  players[i] = 0;
        -:  520:	}
        -:  521:    }
        -:  522:
    #####:  523:  return 0;
        -:  524:}
        -:  525:
function drawCard called 345 returned 100% blocks executed 92%
      345:  526:int drawCard(int player, struct gameState *state)
        -:  527:{	int count;
        -:  528:  int deckCounter;
      345:  529:  if (state->deckCount[player] <= 0){//Deck is empty
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -:  530:    
        -:  531:    //Step 1 Shuffle the discard pile back into a deck
        -:  532:    int i;
        -:  533:    //Move discard to deck
       35:  534:    for (i = 0; i < state->discardCount[player];i++){
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
       34:  535:      state->deck[player][i] = state->discard[player][i];
       34:  536:      state->discard[player][i] = -1;
        -:  537:    }
        -:  538:
        1:  539:    state->deckCount[player] = state->discardCount[player];
        1:  540:    state->discardCount[player] = 0;//Reset discard
        -:  541:
        -:  542:    //Shufffle the deck
        1:  543:    shuffle(player, state);//Shuffle the deck up and make it so that we can draw
call    0 returned 100%
        -:  544:   
        -:  545:    if (DEBUG){//Debug statements
        -:  546:      printf("Deck count now: %d\n", state->deckCount[player]);
        -:  547:    }
        -:  548:    
        1:  549:    state->discardCount[player] = 0;
        -:  550:
        -:  551:    //Step 2 Draw Card
        1:  552:    count = state->handCount[player];//Get current player's hand count
        -:  553:    
        -:  554:    if (DEBUG){//Debug statements
        -:  555:      printf("Current hand count: %d\n", count);
        -:  556:    }
        -:  557:    
        1:  558:    deckCounter = state->deckCount[player];//Create a holder for the deck count
        -:  559:
        1:  560:    if (deckCounter == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  561:      return -1;
        -:  562:
        1:  563:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to hand
        1:  564:    state->deckCount[player]--;
        1:  565:    state->handCount[player]++;//Increment hand count
        -:  566:  }
        -:  567:
        -:  568:  else{
      344:  569:    int count = state->handCount[player];//Get current hand count for player
        -:  570:    int deckCounter;
        -:  571:    if (DEBUG){//Debug statements
        -:  572:      printf("Current hand count: %d\n", count);
        -:  573:    }
        -:  574:
      344:  575:    deckCounter = state->deckCount[player];//Create holder for the deck count
      344:  576:    state->hand[player][count] = state->deck[player][deckCounter - 1];//Add card to the hand
      344:  577:    state->deckCount[player]--;
      344:  578:    state->handCount[player]++;//Increment hand count
        -:  579:  }
        -:  580:
      345:  581:  return 0;
        -:  582:}
        -:  583:
function getCost called 0 returned 0% blocks executed 0%
    #####:  584:int getCost(int cardNumber)
        -:  585:{
    #####:  586:  switch( cardNumber ) 
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
        -:  587:    {
        -:  588:    case curse:
    #####:  589:      return 0;
        -:  590:    case estate:
    #####:  591:      return 2;
        -:  592:    case duchy:
    #####:  593:      return 5;
        -:  594:    case province:
    #####:  595:      return 8;
        -:  596:    case copper:
    #####:  597:      return 0;
        -:  598:    case silver:
    #####:  599:      return 3;
        -:  600:    case gold:
    #####:  601:      return 6;
        -:  602:    case adventurer:
    #####:  603:      return 6;
        -:  604:    case council_room:
    #####:  605:      return 5;
        -:  606:    case feast:
    #####:  607:      return 4;
        -:  608:    case gardens:
    #####:  609:      return 4;
        -:  610:    case mine:
    #####:  611:      return 5;
        -:  612:    case remodel:
    #####:  613:      return 4;
        -:  614:    case smithy:
    #####:  615:      return 4;
        -:  616:    case village:
    #####:  617:      return 3;
        -:  618:    case baron:
    #####:  619:      return 4;
        -:  620:    case great_hall:
    #####:  621:      return 3;
        -:  622:    case minion:
    #####:  623:      return 5;
        -:  624:    case steward:
    #####:  625:      return 3;
        -:  626:    case tribute:
    #####:  627:      return 5;
        -:  628:    case ambassador:
    #####:  629:      return 3;
        -:  630:    case cutpurse:
    #####:  631:      return 4;
        -:  632:    case embargo: 
    #####:  633:      return 2;
        -:  634:    case outpost:
    #####:  635:      return 5;
        -:  636:    case salvager:
    #####:  637:      return 4;
        -:  638:    case sea_hag:
    #####:  639:      return 4;
        -:  640:    case treasure_map:
    #####:  641:      return 4;
        -:  642:    }
        -:  643:	
    #####:  644:  return -1;
        -:  645:}
        -:  646:
        -:  647:
function Smithy called 0 returned 0% blocks executed 0%
    #####:  648:int Smithy(int currentPlayer, struct gameState *state, int handPos){
        -:  649:     //+3 Cards
    #####:  650:  for (int i = 0; i <= 3; i++)
branch  0 never executed
branch  1 never executed
        -:  651:  {
    #####:  652:    drawCard(currentPlayer, state);
call    0 never executed
        -:  653:  }
        -:  654:      
        -:  655:  //discard card from hand
    #####:  656:  discardCard(currentPlayer, handPos, state, 0);
call    0 never executed
    #####:  657:  return 0;
        -:  658:}
        -:  659:
        -:  660: 
function Adventurer called 0 returned 0% blocks executed 0%
    #####:  661:int Adventurer(struct gameState *state, int currentPlayer){
    #####:  662:     int z=1;
        -:  663:     int temphand[MAX_HAND];
    #####:  664:     int drawntreasure=0;
    #####:  665:while(drawntreasure<2){
branch  0 never executed
branch  1 never executed
    #####:  666:    if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
branch  0 never executed
branch  1 never executed
    #####:  667:       shuffle(currentPlayer, state);
call    0 never executed
        -:  668:    }
    #####:  669:    drawCard(currentPlayer, state);
call    0 never executed
    #####:  670:    int cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]+1];//top card of hand is most recently drawn card.
    #####:  671:    if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  672:       drawntreasure++;
        -:  673:    else{
    #####:  674:       temphand[z]=cardDrawn;
    #####:  675:       state->handCount[currentPlayer]++; //this should just remove the top card (the most recently drawn one).
    #####:  676:       z++;
        -:  677:    }
        -:  678: }
    #####:  679:  while(z-1>=0){
branch  0 never executed
branch  1 never executed
    #####:  680:    state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
    #####:  681:    z=z-1;
        -:  682:  }
    #####:  683:  return 0;
        -:  684: }
        -:  685:
        -:  686:
function Village called 100 returned 100% blocks executed 100%
      100:  687:int Village(int currentPlayer, struct gameState *state, int handPos){
        -:  688:   //+1 Card
      100:  689:      drawCard(currentPlayer, state);
call    0 returned 100%
        -:  690:      
        -:  691:      //+2 Actions
      100:  692:      state->numActions = state->numActions + 2;
        -:  693:      
        -:  694:      //discard played card from hand
      100:  695:      discardCard(handPos, currentPlayer, state, 1);
call    0 returned 100%
      100:  696:      return 0;
        -:  697:}
        -:  698:
        -:  699:
function Council_room called 0 returned 0% blocks executed 0%
    #####:  700:int Council_room(int currentPlayer, struct gameState *state, int handPos){
        -:  701:       //+4 Cards
        -:  702:  int i;
    #####:  703:  for (i = 0; i < 5; i++)
branch  0 never executed
branch  1 never executed
        -:  704:  {
    #####:  705:    drawCard(currentPlayer, state);
call    0 never executed
        -:  706:  }
        -:  707:      
        -:  708:      //+1 Buy
    #####:  709:      state->numBuys++;
        -:  710:      
        -:  711:      //Each other player draws a card
    #####:  712:  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -:  713:  {
    #####:  714:    if ( i == currentPlayer )
branch  0 never executed
branch  1 never executed
        -:  715:      {
    #####:  716:        drawCard(i, state);
call    0 never executed
        -:  717:      }
        -:  718:  }
        -:  719:      
        -:  720:      //put played card in played card pile
    #####:  721:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  722:      
    #####:  723:      return 0;
        -:  724:}
        -:  725:
function Feast called 0 returned 0% blocks executed 0%
    #####:  726:int Feast(int currentPlayer, struct gameState *state, int choice1){
        -:  727:        //gain card with cost up to 5
        -:  728:      //Backup hand
        -:  729:  int i;
        -:  730:  int temphand[MAX_HAND];// moved above the if statement
        -:  731:  int x;
        -:  732:
    #####:  733:  for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  734:  temphand[i] = state->hand[currentPlayer][i];//Backup card
    #####:  735:  state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  736:      }
        -:  737:      //Backup hand
        -:  738:
        -:  739:      //Update Coins for Buy
    #####:  740:      updateCoins(currentPlayer, state, 5);
call    0 never executed
    #####:  741:      x = 1;//Condition to loop on
    #####:  742:      while( x == 1) {//Buy one card
branch  0 never executed
branch  1 never executed
    #####:  743:  if (supplyCount(choice1, state) <= 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  744:    if (DEBUG)
        -:  745:      printf("None of that card left, sorry!\n");
        -:  746:
        -:  747:    if (DEBUG){
        -:  748:      printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  749:    }
        -:  750:  }
    #####:  751:  else if (state->coins < getCost(choice1)){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  752:    printf("That card is too expensive!\n");
call    0 never executed
        -:  753:
        -:  754:    if (DEBUG){
        -:  755:      printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  756:    }
        -:  757:  }
        -:  758:  else{
        -:  759:
        -:  760:    if (DEBUG){
        -:  761:      printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  762:    }
        -:  763:
    #####:  764:    gainCard(choice1, state, 0, currentPlayer);//Gain the card
call    0 never executed
    #####:  765:    x = 0;//No more buying cards
        -:  766:
        -:  767:    if (DEBUG){
        -:  768:      printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  769:    }
        -:  770:
        -:  771:  }
        -:  772:      }     
        -:  773:
        -:  774:      //Reset Hand
    #####:  775:  for (i = 0; i <= state->handCount[currentPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####:  776:  state->hand[currentPlayer][i] = temphand[i];
    #####:  777:  temphand[i] = -1;
        -:  778:      }
        -:  779:      //Reset Hand
        -:  780:            
    #####:  781:      return 0;
        -:  782:}
        -:  783:
        -:  784:
        -:  785:
        -:  786:
        -:  787:
        -:  788:
        -:  789:
        -:  790:
        -:  791:
        -:  792:
        -:  793:
function cardEffect called 100 returned 100% blocks executed 3%
      100:  794:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state, int handPos, int *bonus)
        -:  795:{
        -:  796:  int i;
        -:  797:  int j;
        -:  798:  int k;
        -:  799:  int x;
        -:  800:  int index;
      100:  801:  int currentPlayer = whoseTurn(state);
call    0 returned 100%
      100:  802:  int nextPlayer = currentPlayer + 1;
      100:  803:  int tributeRevealedCards[2] = {-1, -1};
        -:  804:  int temphand[MAX_HAND];// moved above the if statement
      100:  805:  int drawntreasure=0;
        -:  806:  int cardDrawn;
      100:  807:  int z = 0;// this is the counter for the temp hand
      100:  808:  if (nextPlayer > (state->numPlayers - 1)){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  809:    nextPlayer = 0;
        -:  810:  }
        -:  811:  
        -:  812:	
        -:  813:  //uses switch to select card and perform actions
      100:  814:  switch( card ) 
branch  0 taken 0%
branch  1 taken 0%
branch  2 taken 0%
branch  3 taken 0%
branch  4 taken 0%
branch  5 taken 0%
branch  6 taken 0%
branch  7 taken 100%
branch  8 taken 0%
branch  9 taken 0%
branch 10 taken 0%
branch 11 taken 0%
branch 12 taken 0%
branch 13 taken 0%
branch 14 taken 0%
branch 15 taken 0%
branch 16 taken 0%
branch 17 taken 0%
branch 18 taken 0%
branch 19 taken 0%
branch 20 taken 0%
        -:  815:    {
        -:  816:    case adventurer:
    #####:  817:      return Adventurer(state, currentPlayer);
call    0 never executed
        -:  818: //      while(drawntreasure<2){
        -:  819:	// if (state->deckCount[currentPlayer] <1){//if the deck is empty we need to shuffle discard and add to deck
        -:  820:	//   shuffle(currentPlayer, state);
        -:  821:	// }
        -:  822:	// drawCard(currentPlayer, state);
        -:  823:	// cardDrawn = state->hand[currentPlayer][state->handCount[currentPlayer]-1];//top card of hand is most recently drawn card.
        -:  824:	// if (cardDrawn == copper || cardDrawn == silver || cardDrawn == gold)
        -:  825:	//   drawntreasure++;
        -:  826:	// else{
        -:  827:	//   temphand[z]=cardDrawn;
        -:  828:	//   state->handCount[currentPlayer]--; //this should just remove the top card (the most recently drawn one).
        -:  829:	//   z++;
        -:  830:	// }
        -:  831: //      }
        -:  832: //      while(z-1>=0){
        -:  833:	// state->discard[currentPlayer][state->discardCount[currentPlayer]++]=temphand[z-1]; // discard all cards in play that have been drawn
        -:  834:	// z=z-1;
        -:  835: //      }
        -:  836: //      return 0;
        -:  837:			
        -:  838:    case council_room:
    #####:  839:       return Council_room(currentPlayer, state, handPos);
call    0 never executed
        -:  840: //      //+4 Cards
        -:  841: //      for (i = 0; i < 4; i++)
        -:  842:	// {
        -:  843:	//   drawCard(currentPlayer, state);
        -:  844:	// }
        -:  845:			
        -:  846: //      //+1 Buy
        -:  847: //      state->numBuys++;
        -:  848:			
        -:  849: //      //Each other player draws a card
        -:  850: //      for (i = 0; i < state->numPlayers; i++)
        -:  851:	// {
        -:  852:	//   if ( i != currentPlayer )
        -:  853:	//     {
        -:  854:	//       drawCard(i, state);
        -:  855:	//     }
        -:  856:	// }
        -:  857:			
        -:  858: //      //put played card in played card pile
        -:  859: //      discardCard(handPos, currentPlayer, state, 0);
        -:  860:			
        -:  861: //      return 0;
        -:  862:			
        -:  863:    case feast:
    #####:  864:       return Feast(currentPlayer, state, choice1);
call    0 never executed
        -:  865: //      //gain card with cost up to 5
        -:  866: //      //Backup hand
        -:  867: //      for (i = 0; i <= state->handCount[currentPlayer]; i++){
        -:  868:	// temphand[i] = state->hand[currentPlayer][i];//Backup card
        -:  869:	// state->hand[currentPlayer][i] = -1;//Set to nothing
        -:  870: //      }
        -:  871: //      //Backup hand
        -:  872:
        -:  873: //      //Update Coins for Buy
        -:  874: //      updateCoins(currentPlayer, state, 5);
        -:  875: //      x = 1;//Condition to loop on
        -:  876: //      while( x == 1) {//Buy one card
        -:  877:	// if (supplyCount(choice1, state) <= 0){
        -:  878:	//   if (DEBUG)
        -:  879:	//     printf("None of that card left, sorry!\n");
        -:  880:
        -:  881:	//   if (DEBUG){
        -:  882:	//     printf("Cards Left: %d\n", supplyCount(choice1, state));
        -:  883:	//   }
        -:  884:	// }
        -:  885:	// else if (state->coins < getCost(choice1)){
        -:  886:	//   printf("That card is too expensive!\n");
        -:  887:
        -:  888:	//   if (DEBUG){
        -:  889:	//     printf("Coins: %d < %d\n", state->coins, getCost(choice1));
        -:  890:	//   }
        -:  891:	// }
        -:  892:	// else{
        -:  893:
        -:  894:	//   if (DEBUG){
        -:  895:	//     printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  896:	//   }
        -:  897:
        -:  898:	//   gainCard(choice1, state, 0, currentPlayer);//Gain the card
        -:  899:	//   x = 0;//No more buying cards
        -:  900:
        -:  901:	//   if (DEBUG){
        -:  902:	//     printf("Deck Count: %d\n", state->handCount[currentPlayer] + state->deckCount[currentPlayer] + state->discardCount[currentPlayer]);
        -:  903:	//   }
        -:  904:
        -:  905:	// }
        -:  906: //      }     
        -:  907:
        -:  908: //      //Reset Hand
        -:  909: //      for (i = 0; i <= state->handCount[currentPlayer]; i++){
        -:  910:	// state->hand[currentPlayer][i] = temphand[i];
        -:  911:	// temphand[i] = -1;
        -:  912: //      }
        -:  913: //      //Reset Hand
        -:  914:      			
        -:  915: //      return 0;
        -:  916:			
        -:  917:    case gardens:
    #####:  918:      return -1;
        -:  919:			
        -:  920:    case mine:
    #####:  921:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  922:
    #####:  923:      if (state->hand[currentPlayer][choice1] < copper || state->hand[currentPlayer][choice1] > gold)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  924:	{
    #####:  925:	  return -1;
        -:  926:	}
        -:  927:		
    #####:  928:      if (choice2 > treasure_map || choice2 < curse)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  929:	{
    #####:  930:	  return -1;
        -:  931:	}
        -:  932:
    #####:  933:      if ( (getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  934:	{
    #####:  935:	  return -1;
        -:  936:	}
        -:  937:
    #####:  938:      gainCard(choice2, state, 2, currentPlayer);
call    0 never executed
        -:  939:
        -:  940:      //discard card from hand
    #####:  941:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  942:
        -:  943:      //discard trashed card
    #####:  944:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  945:	{
    #####:  946:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  947:	    {
    #####:  948:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  949:	      break;
        -:  950:	    }
        -:  951:	}
        -:  952:			
    #####:  953:      return 0;
        -:  954:			
        -:  955:    case remodel:
    #####:  956:      j = state->hand[currentPlayer][choice1];  //store card we will trash
        -:  957:
    #####:  958:      if ( (getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2) )
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
        -:  959:	{
    #####:  960:	  return -1;
        -:  961:	}
        -:  962:
    #####:  963:      gainCard(choice2, state, 0, currentPlayer);
call    0 never executed
        -:  964:
        -:  965:      //discard card from hand
    #####:  966:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -:  967:
        -:  968:      //discard trashed card
    #####:  969:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -:  970:	{
    #####:  971:	  if (state->hand[currentPlayer][i] == j)
branch  0 never executed
branch  1 never executed
        -:  972:	    {
    #####:  973:	      discardCard(i, currentPlayer, state, 0);			
call    0 never executed
    #####:  974:	      break;
        -:  975:	    }
        -:  976:	}
        -:  977:
        -:  978:
    #####:  979:      return 0;
        -:  980:		
        -:  981:    case smithy:
    #####:  982:      return Smithy(currentPlayer, state, handPos);
call    0 never executed
        -:  983: //      //+3 Cards
        -:  984: //      for (i = 0; i < 3; i++)
        -:  985:	// {
        -:  986:	//   drawCard(currentPlayer, state);
        -:  987:	// }
        -:  988:			
        -:  989: //      //discard card from hand
        -:  990: //      discardCard(handPos, currentPlayer, state, 0);
        -:  991: //      return 0;
        -:  992:		
        -:  993:    case village:
      100:  994:      return Village(handPos, state, currentPlayer);
call    0 returned 100%
        -:  995:      // //+1 Card
        -:  996:      // drawCard(currentPlayer, state);
        -:  997:			
        -:  998:      // //+2 Actions
        -:  999:      // state->numActions = state->numActions + 2;
        -: 1000:			
        -: 1001:      // //discard played card from hand
        -: 1002:      // discardCard(handPos, currentPlayer, state, 0);
        -: 1003:      // return 0;
        -: 1004:		
        -: 1005:    case baron:
    #####: 1006:      state->numBuys++;//Increase buys by 1!
    #####: 1007:      if (choice1 > 0){//Boolean true or going to discard an estate
branch  0 never executed
branch  1 never executed
    #####: 1008:	int p = 0;//Iterator for hand!
    #####: 1009:	int card_not_discarded = 1;//Flag for discard set!
    #####: 1010:	while(card_not_discarded){
branch  0 never executed
branch  1 never executed
    #####: 1011:	  if (state->hand[currentPlayer][p] == estate){//Found an estate card!
branch  0 never executed
branch  1 never executed
    #####: 1012:	    state->coins += 4;//Add 4 coins to the amount of coins
    #####: 1013:	    state->discard[currentPlayer][state->discardCount[currentPlayer]] = state->hand[currentPlayer][p];
    #####: 1014:	    state->discardCount[currentPlayer]++;
    #####: 1015:	    for (;p < state->handCount[currentPlayer]; p++){
branch  0 never executed
branch  1 never executed
    #####: 1016:	      state->hand[currentPlayer][p] = state->hand[currentPlayer][p+1];
        -: 1017:	    }
    #####: 1018:	    state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####: 1019:	    state->handCount[currentPlayer]--;
    #####: 1020:	    card_not_discarded = 0;//Exit the loop
        -: 1021:	  }
    #####: 1022:	  else if (p > state->handCount[currentPlayer]){
branch  0 never executed
branch  1 never executed
        -: 1023:	    if(DEBUG) {
        -: 1024:	      printf("No estate cards in your hand, invalid choice\n");
        -: 1025:	      printf("Must gain an estate if there are any\n");
        -: 1026:	    }
    #####: 1027:	    if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1028:	      gainCard(estate, state, 0, currentPlayer);
call    0 never executed
    #####: 1029:	      state->supplyCount[estate]--;//Decrement estates
    #####: 1030:	      if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1031:		isGameOver(state);
call    0 never executed
        -: 1032:	      }
        -: 1033:	    }
    #####: 1034:	    card_not_discarded = 0;//Exit the loop
        -: 1035:	  }
        -: 1036:			    
        -: 1037:	  else{
    #####: 1038:	    p++;//Next card
        -: 1039:	  }
        -: 1040:	}
        -: 1041:      }
        -: 1042:			    
        -: 1043:      else{
    #####: 1044:	if (supplyCount(estate, state) > 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1045:	  gainCard(estate, state, 0, currentPlayer);//Gain an estate
call    0 never executed
    #####: 1046:	  state->supplyCount[estate]--;//Decrement Estates
    #####: 1047:	  if (supplyCount(estate, state) == 0){
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1048:	    isGameOver(state);
call    0 never executed
        -: 1049:	  }
        -: 1050:	}
        -: 1051:      }
        -: 1052:	    
        -: 1053:      
    #####: 1054:      return 0;
        -: 1055:		
        -: 1056:    case great_hall:
        -: 1057:      //+1 Card
    #####: 1058:      drawCard(currentPlayer, state);
call    0 never executed
        -: 1059:			
        -: 1060:      //+1 Actions
    #####: 1061:      state->numActions++;
        -: 1062:			
        -: 1063:      //discard card from hand
    #####: 1064:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1065:      return 0;
        -: 1066:		
        -: 1067:    case minion:
        -: 1068:      //+1 action
    #####: 1069:      state->numActions++;
        -: 1070:			
        -: 1071:      //discard card from hand
    #####: 1072:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1073:			
    #####: 1074:      if (choice1)		//+2 coins
branch  0 never executed
branch  1 never executed
        -: 1075:	{
    #####: 1076:	  state->coins = state->coins + 2;
        -: 1077:	}
        -: 1078:			
    #####: 1079:      else if (choice2)		//discard hand, redraw 4, other players with 5+ cards discard hand and draw 4
branch  0 never executed
branch  1 never executed
        -: 1080:	{
        -: 1081:	  //discard hand
    #####: 1082:	  while(numHandCards(state) > 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1083:	    {
    #####: 1084:	      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
        -: 1085:	    }
        -: 1086:				
        -: 1087:	  //draw 4
    #####: 1088:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1089:	    {
    #####: 1090:	      drawCard(currentPlayer, state);
call    0 never executed
        -: 1091:	    }
        -: 1092:				
        -: 1093:	  //other players discard hand and redraw if hand size > 4
    #####: 1094:	  for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1095:	    {
    #####: 1096:	      if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1097:		{
    #####: 1098:		  if ( state->handCount[i] > 4 )
branch  0 never executed
branch  1 never executed
        -: 1099:		    {
        -: 1100:		      //discard hand
    #####: 1101:		      while( state->handCount[i] > 0 )
branch  0 never executed
branch  1 never executed
        -: 1102:			{
    #####: 1103:			  discardCard(handPos, i, state, 0);
call    0 never executed
        -: 1104:			}
        -: 1105:							
        -: 1106:		      //draw 4
    #####: 1107:		      for (j = 0; j < 4; j++)
branch  0 never executed
branch  1 never executed
        -: 1108:			{
    #####: 1109:			  drawCard(i, state);
call    0 never executed
        -: 1110:			}
        -: 1111:		    }
        -: 1112:		}
        -: 1113:	    }
        -: 1114:				
        -: 1115:	}
    #####: 1116:      return 0;
        -: 1117:		
        -: 1118:    case steward:
    #####: 1119:      if (choice1 == 1)
branch  0 never executed
branch  1 never executed
        -: 1120:	{
        -: 1121:	  //+2 cards
    #####: 1122:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1123:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1124:	}
    #####: 1125:      else if (choice1 == 2)
branch  0 never executed
branch  1 never executed
        -: 1126:	{
        -: 1127:	  //+2 coins
    #####: 1128:	  state->coins = state->coins + 2;
        -: 1129:	}
        -: 1130:      else
        -: 1131:	{
        -: 1132:	  //trash 2 cards in hand
    #####: 1133:	  discardCard(choice2, currentPlayer, state, 1);
call    0 never executed
    #####: 1134:	  discardCard(choice3, currentPlayer, state, 1);
call    0 never executed
        -: 1135:	}
        -: 1136:			
        -: 1137:      //discard card from hand
    #####: 1138:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1139:      return 0;
        -: 1140:		
        -: 1141:    case tribute:
    #####: 1142:      if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1){
branch  0 never executed
branch  1 never executed
    #####: 1143:	if (state->deckCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1144:	  tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1145:	  state->deckCount[nextPlayer]--;
        -: 1146:	}
    #####: 1147:	else if (state->discardCount[nextPlayer] > 0){
branch  0 never executed
branch  1 never executed
    #####: 1148:	  tributeRevealedCards[0] = state->discard[nextPlayer][state->discardCount[nextPlayer]-1];
    #####: 1149:	  state->discardCount[nextPlayer]--;
        -: 1150:	}
        -: 1151:	else{
        -: 1152:	  //No Card to Reveal
        -: 1153:	  if (DEBUG){
        -: 1154:	    printf("No cards to reveal\n");
        -: 1155:	  }
        -: 1156:	}
        -: 1157:      }
        -: 1158:	    
        -: 1159:      else{
    #####: 1160:	if (state->deckCount[nextPlayer] == 0){
branch  0 never executed
branch  1 never executed
    #####: 1161:	  for (i = 0; i < state->discardCount[nextPlayer]; i++){
branch  0 never executed
branch  1 never executed
    #####: 1162:	    state->deck[nextPlayer][i] = state->discard[nextPlayer][i];//Move to deck
    #####: 1163:	    state->deckCount[nextPlayer]++;
    #####: 1164:	    state->discard[nextPlayer][i] = -1;
    #####: 1165:	    state->discardCount[nextPlayer]--;
        -: 1166:	  }
        -: 1167:			    
    #####: 1168:	  shuffle(nextPlayer,state);//Shuffle the deck
call    0 never executed
        -: 1169:	} 
    #####: 1170:	tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1171:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1172:	state->deckCount[nextPlayer]--;
    #####: 1173:	tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer]-1];
    #####: 1174:	state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1175:	state->deckCount[nextPlayer]--;
        -: 1176:      }    
        -: 1177:		       
    #####: 1178:      if (tributeRevealedCards[0] == tributeRevealedCards[1]){//If we have a duplicate card, just drop one 
branch  0 never executed
branch  1 never executed
    #####: 1179:	state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1180:	state->playedCardCount++;
    #####: 1181:	tributeRevealedCards[1] = -1;
        -: 1182:      }
        -: 1183:
    #####: 1184:      for (i = 0; i <= 2; i ++){
branch  0 never executed
branch  1 never executed
    #####: 1185:	if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver || tributeRevealedCards[i] == gold){//Treasure cards
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1186:	  state->coins += 2;
        -: 1187:	}
        -: 1188:		    
    #####: 1189:	else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy || tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens || tributeRevealedCards[i] == great_hall){//Victory Card Found
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####: 1190:	  drawCard(currentPlayer, state);
call    0 never executed
    #####: 1191:	  drawCard(currentPlayer, state);
call    0 never executed
        -: 1192:	}
        -: 1193:	else{//Action Card
    #####: 1194:	  state->numActions = state->numActions + 2;
        -: 1195:	}
        -: 1196:      }
        -: 1197:	    
    #####: 1198:      return 0;
        -: 1199:		
        -: 1200:    case ambassador:
    #####: 1201:      j = 0;		//used to check if player has enough cards to discard
        -: 1202:
    #####: 1203:      if (choice2 > 2 || choice2 < 0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1204:	{
    #####: 1205:	  return -1;				
        -: 1206:	}
        -: 1207:
    #####: 1208:      if (choice1 == handPos)
branch  0 never executed
branch  1 never executed
        -: 1209:	{
    #####: 1210:	  return -1;
        -: 1211:	}
        -: 1212:
    #####: 1213:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1214:	{
    #####: 1215:	  if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1216:	    {
    #####: 1217:	      j++;
        -: 1218:	    }
        -: 1219:	}
    #####: 1220:      if (j < choice2)
branch  0 never executed
branch  1 never executed
        -: 1221:	{
    #####: 1222:	  return -1;				
        -: 1223:	}
        -: 1224:
        -: 1225:      if (DEBUG) 
        -: 1226:	printf("Player %d reveals card number: %d\n", currentPlayer, state->hand[currentPlayer][choice1]);
        -: 1227:
        -: 1228:      //increase supply count for choosen card by amount being discarded
    #####: 1229:      state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1230:			
        -: 1231:      //each other player gains a copy of revealed card
    #####: 1232:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1233:	{
    #####: 1234:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1235:	    {
    #####: 1236:	      gainCard(state->hand[currentPlayer][choice1], state, 0, i);
call    0 never executed
        -: 1237:	    }
        -: 1238:	}
        -: 1239:
        -: 1240:      //discard played card from hand
    #####: 1241:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1242:
        -: 1243:      //trash copies of cards returned to supply
    #####: 1244:      for (j = 0; j < choice2; j++)
branch  0 never executed
branch  1 never executed
        -: 1245:	{
    #####: 1246:	  for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1247:	    {
    #####: 1248:	      if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
branch  0 never executed
branch  1 never executed
        -: 1249:		{
    #####: 1250:		  discardCard(i, currentPlayer, state, 1);
call    0 never executed
    #####: 1251:		  break;
        -: 1252:		}
        -: 1253:	    }
        -: 1254:	}			
        -: 1255:
    #####: 1256:      return 0;
        -: 1257:		
        -: 1258:    case cutpurse:
        -: 1259:
    #####: 1260:      updateCoins(currentPlayer, state, 2);
call    0 never executed
    #####: 1261:      for (i = 0; i < state->numPlayers; i++)
branch  0 never executed
branch  1 never executed
        -: 1262:	{
    #####: 1263:	  if (i != currentPlayer)
branch  0 never executed
branch  1 never executed
        -: 1264:	    {
    #####: 1265:	      for (j = 0; j < state->handCount[i]; j++)
branch  0 never executed
branch  1 never executed
        -: 1266:		{
    #####: 1267:		  if (state->hand[i][j] == copper)
branch  0 never executed
branch  1 never executed
        -: 1268:		    {
    #####: 1269:		      discardCard(j, i, state, 0);
call    0 never executed
    #####: 1270:		      break;
        -: 1271:		    }
    #####: 1272:		  if (j == state->handCount[i])
branch  0 never executed
branch  1 never executed
        -: 1273:		    {
    #####: 1274:		      for (k = 0; k < state->handCount[i]; k++)
branch  0 never executed
branch  1 never executed
        -: 1275:			{
        -: 1276:			  if (DEBUG)
        -: 1277:			    printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1278:			}	
    #####: 1279:		      break;
        -: 1280:		    }		
        -: 1281:		}
        -: 1282:					
        -: 1283:	    }
        -: 1284:				
        -: 1285:	}				
        -: 1286:
        -: 1287:      //discard played card from hand
    #####: 1288:      discardCard(handPos, currentPlayer, state, 0);			
call    0 never executed
        -: 1289:
    #####: 1290:      return 0;
        -: 1291:
        -: 1292:		
        -: 1293:    case embargo: 
        -: 1294:      //+2 Coins
    #####: 1295:      state->coins = state->coins + 2;
        -: 1296:			
        -: 1297:      //see if selected pile is in play
    #####: 1298:      if ( state->supplyCount[choice1] == -1 )
branch  0 never executed
branch  1 never executed
        -: 1299:	{
    #####: 1300:	  return -1;
        -: 1301:	}
        -: 1302:			
        -: 1303:      //add embargo token to selected supply pile
    #####: 1304:      state->embargoTokens[choice1]++;
        -: 1305:			
        -: 1306:      //trash card
    #####: 1307:      discardCard(handPos, currentPlayer, state, 1);		
call    0 never executed
    #####: 1308:      return 0;
        -: 1309:		
        -: 1310:    case outpost:
        -: 1311:      //set outpost flag
    #####: 1312:      state->outpostPlayed++;
        -: 1313:			
        -: 1314:      //discard card
    #####: 1315:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1316:      return 0;
        -: 1317:		
        -: 1318:    case salvager:
        -: 1319:      //+1 buy
    #####: 1320:      state->numBuys++;
        -: 1321:			
    #####: 1322:      if (choice1)
branch  0 never executed
branch  1 never executed
        -: 1323:	{
        -: 1324:	  //gain coins equal to trashed card
    #####: 1325:	  state->coins = state->coins + getCost( handCard(choice1, state) );
call    0 never executed
call    1 never executed
        -: 1326:	  //trash card
    #####: 1327:	  discardCard(choice1, currentPlayer, state, 1);	
call    0 never executed
        -: 1328:	}
        -: 1329:			
        -: 1330:      //discard card
    #####: 1331:      discardCard(handPos, currentPlayer, state, 0);
call    0 never executed
    #####: 1332:      return 0;
        -: 1333:		
        -: 1334:    case sea_hag:
    #####: 1335:      for (i = 0; i < state->numPlayers; i++){
branch  0 never executed
branch  1 never executed
    #####: 1336:	if (i != currentPlayer){
branch  0 never executed
branch  1 never executed
    #####: 1337:	  state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];			    state->deckCount[i]--;
    #####: 1338:	  state->discardCount[i]++;
    #####: 1339:	  state->deck[i][state->deckCount[i]--] = curse;//Top card now a curse
        -: 1340:	}
        -: 1341:      }
    #####: 1342:      return 0;
        -: 1343:		
        -: 1344:    case treasure_map:
        -: 1345:      //search hand for another treasure_map
    #####: 1346:      index = -1;
    #####: 1347:      for (i = 0; i < state->handCount[currentPlayer]; i++)
branch  0 never executed
branch  1 never executed
        -: 1348:	{
    #####: 1349:	  if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1350:	    {
    #####: 1351:	      index = i;
    #####: 1352:	      break;
        -: 1353:	    }
        -: 1354:	}
    #####: 1355:      if (index > -1)
branch  0 never executed
branch  1 never executed
        -: 1356:	{
        -: 1357:	  //trash both treasure cards
    #####: 1358:	  discardCard(handPos, currentPlayer, state, 1);
call    0 never executed
    #####: 1359:	  discardCard(index, currentPlayer, state, 1);
call    0 never executed
        -: 1360:
        -: 1361:	  //gain 4 Gold cards
    #####: 1362:	  for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -: 1363:	    {
    #####: 1364:	      gainCard(gold, state, 1, currentPlayer);
call    0 never executed
        -: 1365:	    }
        -: 1366:				
        -: 1367:	  //return success
    #####: 1368:	  return 1;
        -: 1369:	}
        -: 1370:			
        -: 1371:      //no second treasure_map found in hand
    #####: 1372:      return -1;
        -: 1373:    }
        -: 1374:	
    #####: 1375:  return -1;
        -: 1376:}
        -: 1377:
function discardCard called 100 returned 100% blocks executed 67%
      100: 1378:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1379:{
        -: 1380:	
        -: 1381:  //if card is not trashed, added to Played pile 
      100: 1382:  if (trashFlag < 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1383:    {
        -: 1384:      //add card to played pile
    #####: 1385:      state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos]; 
    #####: 1386:      state->playedCardCount++;
        -: 1387:    }
        -: 1388:	
        -: 1389:  //set played card to -1
      100: 1390:  state->hand[currentPlayer][handPos] = -1;
        -: 1391:	
        -: 1392:  //remove card from player's hand
      100: 1393:  if ( handPos == (state->handCount[currentPlayer] - 1) ) 	//last card in hand array is played
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1394:    {
        -: 1395:      //reduce number of cards in hand
    #####: 1396:      state->handCount[currentPlayer]--;
        -: 1397:    }
      100: 1398:  else if ( state->handCount[currentPlayer] == 1 ) //only one card in hand
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1399:    {
        -: 1400:      //reduce number of cards in hand
    #####: 1401:      state->handCount[currentPlayer]--;
        -: 1402:    }
        -: 1403:  else 	
        -: 1404:    {
        -: 1405:      //replace discarded card with last card in hand
      100: 1406:      state->hand[currentPlayer][handPos] = state->hand[currentPlayer][ (state->handCount[currentPlayer] - 1)];
        -: 1407:      //set last card to -1
      100: 1408:      state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1409:      //reduce number of cards in hand
      100: 1410:      state->handCount[currentPlayer]--;
        -: 1411:    }
        -: 1412:	
      100: 1413:  return 0;
        -: 1414:}
        -: 1415:
function gainCard called 0 returned 0% blocks executed 0%
    #####: 1416:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1417:{
        -: 1418:  //Note: supplyPos is enum of choosen card
        -: 1419:	
        -: 1420:  //check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1421:  if ( supplyCount(supplyPos, state) < 1 )
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1422:    {
    #####: 1423:      return -1;
        -: 1424:    }
        -: 1425:	
        -: 1426:  //added card for [whoseTurn] current player:
        -: 1427:  // toFlag = 0 : add to discard
        -: 1428:  // toFlag = 1 : add to deck
        -: 1429:  // toFlag = 2 : add to hand
        -: 1430:
    #####: 1431:  if (toFlag == 1)
branch  0 never executed
branch  1 never executed
        -: 1432:    {
    #####: 1433:      state->deck[ player ][ state->deckCount[player] ] = supplyPos;
    #####: 1434:      state->deckCount[player]++;
        -: 1435:    }
    #####: 1436:  else if (toFlag == 2)
branch  0 never executed
branch  1 never executed
        -: 1437:    {
    #####: 1438:      state->hand[ player ][ state->handCount[player] ] = supplyPos;
    #####: 1439:      state->handCount[player]++;
        -: 1440:    }
        -: 1441:  else
        -: 1442:    {
    #####: 1443:      state->discard[player][ state->discardCount[player] ] = supplyPos;
    #####: 1444:      state->discardCount[player]++;
        -: 1445:    }
        -: 1446:	
        -: 1447:  //decrease number in supply pile
    #####: 1448:  state->supplyCount[supplyPos]--;
        -: 1449:	 
    #####: 1450:  return 0;
        -: 1451:}
        -: 1452:
function updateCoins called 49 returned 100% blocks executed 82%
       49: 1453:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1454:{
        -: 1455:  int i;
        -: 1456:	
        -: 1457:  //reset coin count
       49: 1458:  state->coins = 0;
        -: 1459:
        -: 1460:  //add coins for each Treasure card in player's hand
      294: 1461:  for (i = 0; i < state->handCount[player]; i++)
branch  0 taken 83%
branch  1 taken 17% (fallthrough)
        -: 1462:    {
      245: 1463:      if (state->hand[player][i] == copper)
branch  0 taken 69% (fallthrough)
branch  1 taken 31%
        -: 1464:	{
      170: 1465:	  state->coins += 1;
        -: 1466:	}
       75: 1467:      else if (state->hand[player][i] == silver)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1468:	{
    #####: 1469:	  state->coins += 2;
        -: 1470:	}
       75: 1471:      else if (state->hand[player][i] == gold)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1472:	{
    #####: 1473:	  state->coins += 3;
        -: 1474:	}	
        -: 1475:    }	
        -: 1476:
        -: 1477:  //add bonus
       49: 1478:  state->coins += bonus;
        -: 1479:
       49: 1480:  return 0;
        -: 1481:}
        -: 1482:
        -: 1483:
        -: 1484://end of dominion.c
        -: 1485:
